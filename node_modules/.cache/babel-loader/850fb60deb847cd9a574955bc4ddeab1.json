{"ast":null,"code":"import { __values, __read, __awaiter, __generator, __spreadArray } from 'tslib';\nimport { Deferred } from '@firebase/util';\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\n\nvar Component =\n/** @class */\nfunction () {\n  /**\r\n   *\r\n   * @param name The public service name, e.g. app, auth, firestore, database\r\n   * @param instanceFactory Service factory responsible for creating the public interface\r\n   * @param type whether the service provided by the component is public or private\r\n   */\n  function Component(name, instanceFactory, type) {\n    this.name = name;\n    this.instanceFactory = instanceFactory;\n    this.type = type;\n    this.multipleInstances = false;\n    /**\r\n     * Properties to be added to the service namespace\r\n     */\n\n    this.serviceProps = {};\n    this.instantiationMode = \"LAZY\"\n    /* LAZY */\n    ;\n    this.onInstanceCreated = null;\n  }\n\n  Component.prototype.setInstantiationMode = function (mode) {\n    this.instantiationMode = mode;\n    return this;\n  };\n\n  Component.prototype.setMultipleInstances = function (multipleInstances) {\n    this.multipleInstances = multipleInstances;\n    return this;\n  };\n\n  Component.prototype.setServiceProps = function (props) {\n    this.serviceProps = props;\n    return this;\n  };\n\n  Component.prototype.setInstanceCreatedCallback = function (callback) {\n    this.onInstanceCreated = callback;\n    return this;\n  };\n\n  return Component;\n}();\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]';\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\n\nvar Provider =\n/** @class */\nfunction () {\n  function Provider(name, container) {\n    this.name = name;\n    this.container = container;\n    this.component = null;\n    this.instances = new Map();\n    this.instancesDeferred = new Map();\n    this.instancesOptions = new Map();\n    this.onInitCallbacks = new Map();\n  }\n  /**\r\n   * @param identifier A provider can provide mulitple instances of a service\r\n   * if this.component.multipleInstances is true.\r\n   */\n\n\n  Provider.prototype.get = function (identifier) {\n    // if multipleInstances is not supported, use the default name\n    var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n\n    if (!this.instancesDeferred.has(normalizedIdentifier)) {\n      var deferred = new Deferred();\n      this.instancesDeferred.set(normalizedIdentifier, deferred);\n\n      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n        // initialize the service if it can be auto-initialized\n        try {\n          var instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier\n          });\n\n          if (instance) {\n            deferred.resolve(instance);\n          }\n        } catch (e) {// when the instance factory throws an exception during get(), it should not cause\n          // a fatal error. We just return the unresolved promise in this case.\n        }\n      }\n    }\n\n    return this.instancesDeferred.get(normalizedIdentifier).promise;\n  };\n\n  Provider.prototype.getImmediate = function (options) {\n    var _a; // if multipleInstances is not supported, use the default name\n\n\n    var normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n    var optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n\n    if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n      try {\n        return this.getOrInitializeService({\n          instanceIdentifier: normalizedIdentifier\n        });\n      } catch (e) {\n        if (optional) {\n          return null;\n        } else {\n          throw e;\n        }\n      }\n    } else {\n      // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\n      if (optional) {\n        return null;\n      } else {\n        throw Error(\"Service \" + this.name + \" is not available\");\n      }\n    }\n  };\n\n  Provider.prototype.getComponent = function () {\n    return this.component;\n  };\n\n  Provider.prototype.setComponent = function (component) {\n    var e_1, _a;\n\n    if (component.name !== this.name) {\n      throw Error(\"Mismatching Component \" + component.name + \" for Provider \" + this.name + \".\");\n    }\n\n    if (this.component) {\n      throw Error(\"Component for \" + this.name + \" has already been provided\");\n    }\n\n    this.component = component; // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n\n    if (!this.shouldAutoInitialize()) {\n      return;\n    } // if the service is eager, initialize the default instance\n\n\n    if (isComponentEager(component)) {\n      try {\n        this.getOrInitializeService({\n          instanceIdentifier: DEFAULT_ENTRY_NAME\n        });\n      } catch (e) {// when the instance factory for an eager Component throws an exception during the eager\n        // initialization, it should not cause a fatal error.\n        // TODO: Investigate if we need to make it configurable, because some component may want to cause\n        // a fatal error in this case?\n      }\n    }\n\n    try {\n      // Create service instances for the pending promises and resolve them\n      // NOTE: if this.multipleInstances is false, only the default instance will be created\n      // and all promises with resolve with it regardless of the identifier.\n      for (var _b = __values(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n            instanceIdentifier = _d[0],\n            instanceDeferred = _d[1];\n\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n\n        try {\n          // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n          var instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier\n          });\n          instanceDeferred.resolve(instance);\n        } catch (e) {// when the instance factory throws an exception, it should not cause\n          // a fatal error. We just leave the promise unresolved.\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n\n  Provider.prototype.clearInstance = function (identifier) {\n    if (identifier === void 0) {\n      identifier = DEFAULT_ENTRY_NAME;\n    }\n\n    this.instancesDeferred.delete(identifier);\n    this.instancesOptions.delete(identifier);\n    this.instances.delete(identifier);\n  }; // app.delete() will call this method on every provider to delete the services\n  // TODO: should we mark the provider as deleted?\n\n\n  Provider.prototype.delete = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var services;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            services = Array.from(this.instances.values());\n            return [4\n            /*yield*/\n            , Promise.all(__spreadArray(__spreadArray([], __read(services.filter(function (service) {\n              return 'INTERNAL' in service;\n            }) // legacy services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map(function (service) {\n              return service.INTERNAL.delete();\n            }))), __read(services.filter(function (service) {\n              return '_delete' in service;\n            }) // modularized services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map(function (service) {\n              return service._delete();\n            }))))];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Provider.prototype.isComponentSet = function () {\n    return this.component != null;\n  };\n\n  Provider.prototype.isInitialized = function (identifier) {\n    if (identifier === void 0) {\n      identifier = DEFAULT_ENTRY_NAME;\n    }\n\n    return this.instances.has(identifier);\n  };\n\n  Provider.prototype.getOptions = function (identifier) {\n    if (identifier === void 0) {\n      identifier = DEFAULT_ENTRY_NAME;\n    }\n\n    return this.instancesOptions.get(identifier) || {};\n  };\n\n  Provider.prototype.initialize = function (opts) {\n    var e_2, _a;\n\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    var _b = opts.options,\n        options = _b === void 0 ? {} : _b;\n    var normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n\n    if (this.isInitialized(normalizedIdentifier)) {\n      throw Error(this.name + \"(\" + normalizedIdentifier + \") has already been initialized\");\n    }\n\n    if (!this.isComponentSet()) {\n      throw Error(\"Component \" + this.name + \" has not been registered yet\");\n    }\n\n    var instance = this.getOrInitializeService({\n      instanceIdentifier: normalizedIdentifier,\n      options: options\n    });\n\n    try {\n      // resolve any pending promise waiting for the service instance\n      for (var _c = __values(this.instancesDeferred.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var _e = __read(_d.value, 2),\n            instanceIdentifier = _e[0],\n            instanceDeferred = _e[1];\n\n        var normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n\n        if (normalizedIdentifier === normalizedDeferredIdentifier) {\n          instanceDeferred.resolve(instance);\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return instance;\n  };\n  /**\r\n   *\r\n   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n   *\r\n   * @param identifier An optional instance identifier\r\n   * @returns a function to unregister the callback\r\n   */\n\n\n  Provider.prototype.onInit = function (callback, identifier) {\n    var _a;\n\n    var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n    var existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\n    existingCallbacks.add(callback);\n    this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n    var existingInstance = this.instances.get(normalizedIdentifier);\n\n    if (existingInstance) {\n      callback(existingInstance, normalizedIdentifier);\n    }\n\n    return function () {\n      existingCallbacks.delete(callback);\n    };\n  };\n  /**\r\n   * Invoke onInit callbacks synchronously\r\n   * @param instance the service instance`\r\n   */\n\n\n  Provider.prototype.invokeOnInitCallbacks = function (instance, identifier) {\n    var e_3, _a;\n\n    var callbacks = this.onInitCallbacks.get(identifier);\n\n    if (!callbacks) {\n      return;\n    }\n\n    try {\n      for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {\n        var callback = callbacks_1_1.value;\n\n        try {\n          callback(instance, identifier);\n        } catch (_b) {// ignore errors in the onInit callback\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n  };\n\n  Provider.prototype.getOrInitializeService = function (_a) {\n    var instanceIdentifier = _a.instanceIdentifier,\n        _b = _a.options,\n        options = _b === void 0 ? {} : _b;\n    var instance = this.instances.get(instanceIdentifier);\n\n    if (!instance && this.component) {\n      instance = this.component.instanceFactory(this.container, {\n        instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n        options: options\n      });\n      this.instances.set(instanceIdentifier, instance);\n      this.instancesOptions.set(instanceIdentifier, options);\n      /**\r\n       * Invoke onInit listeners.\r\n       * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n       * while onInit listeners are registered by consumers of the provider.\r\n       */\n\n      this.invokeOnInitCallbacks(instance, instanceIdentifier);\n      /**\r\n       * Order is important\r\n       * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n       * makes `isInitialized()` return true.\r\n       */\n\n      if (this.component.onInstanceCreated) {\n        try {\n          this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n        } catch (_c) {// ignore errors in the onInstanceCreatedCallback\n        }\n      }\n    }\n\n    return instance || null;\n  };\n\n  Provider.prototype.normalizeInstanceIdentifier = function (identifier) {\n    if (identifier === void 0) {\n      identifier = DEFAULT_ENTRY_NAME;\n    }\n\n    if (this.component) {\n      return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n    } else {\n      return identifier; // assume multiple instances are supported before the component is provided.\n    }\n  };\n\n  Provider.prototype.shouldAutoInitialize = function () {\n    return !!this.component && this.component.instantiationMode !== \"EXPLICIT\"\n    /* EXPLICIT */\n    ;\n  };\n\n  return Provider;\n}(); // undefined should be passed to the service factory for the default instance\n\n\nfunction normalizeIdentifierForFactory(identifier) {\n  return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\n\nfunction isComponentEager(component) {\n  return component.instantiationMode === \"EAGER\"\n  /* EAGER */\n  ;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\n\n\nvar ComponentContainer =\n/** @class */\nfunction () {\n  function ComponentContainer(name) {\n    this.name = name;\n    this.providers = new Map();\n  }\n  /**\r\n   *\r\n   * @param component Component being added\r\n   * @param overwrite When a component with the same name has already been registered,\r\n   * if overwrite is true: overwrite the existing component with the new component and create a new\r\n   * provider with the new component. It can be useful in tests where you want to use different mocks\r\n   * for different tests.\r\n   * if overwrite is false: throw an exception\r\n   */\n\n\n  ComponentContainer.prototype.addComponent = function (component) {\n    var provider = this.getProvider(component.name);\n\n    if (provider.isComponentSet()) {\n      throw new Error(\"Component \" + component.name + \" has already been registered with \" + this.name);\n    }\n\n    provider.setComponent(component);\n  };\n\n  ComponentContainer.prototype.addOrOverwriteComponent = function (component) {\n    var provider = this.getProvider(component.name);\n\n    if (provider.isComponentSet()) {\n      // delete the existing provider from the container, so we can register the new component\n      this.providers.delete(component.name);\n    }\n\n    this.addComponent(component);\n  };\n  /**\r\n   * getProvider provides a type safe interface where it can only be called with a field name\r\n   * present in NameServiceMapping interface.\r\n   *\r\n   * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n   * themselves.\r\n   */\n\n\n  ComponentContainer.prototype.getProvider = function (name) {\n    if (this.providers.has(name)) {\n      return this.providers.get(name);\n    } // create a Provider for a service that hasn't registered with Firebase\n\n\n    var provider = new Provider(name, this);\n    this.providers.set(name, provider);\n    return provider;\n  };\n\n  ComponentContainer.prototype.getProviders = function () {\n    return Array.from(this.providers.values());\n  };\n\n  return ComponentContainer;\n}();\n\nexport { Component, ComponentContainer, Provider };","map":{"version":3,"names":["__values","__read","__awaiter","__generator","__spreadArray","Deferred","Component","name","instanceFactory","type","multipleInstances","serviceProps","instantiationMode","onInstanceCreated","prototype","setInstantiationMode","mode","setMultipleInstances","setServiceProps","props","setInstanceCreatedCallback","callback","DEFAULT_ENTRY_NAME","Provider","container","component","instances","Map","instancesDeferred","instancesOptions","onInitCallbacks","get","identifier","normalizedIdentifier","normalizeInstanceIdentifier","has","deferred","set","isInitialized","shouldAutoInitialize","instance","getOrInitializeService","instanceIdentifier","resolve","e","promise","getImmediate","options","_a","optional","Error","getComponent","setComponent","e_1","isComponentEager","_b","entries","_c","next","done","_d","value","instanceDeferred","e_1_1","error","return","call","clearInstance","delete","services","label","Array","from","values","Promise","all","filter","service","map","INTERNAL","_delete","sent","isComponentSet","getOptions","initialize","opts","e_2","_e","normalizedDeferredIdentifier","e_2_1","onInit","existingCallbacks","Set","add","existingInstance","invokeOnInitCallbacks","e_3","callbacks","callbacks_1","callbacks_1_1","e_3_1","normalizeIdentifierForFactory","undefined","ComponentContainer","providers","addComponent","provider","getProvider","addOrOverwriteComponent","getProviders"],"sources":["/Users/codeninja/Desktop/firebase-project/React-app-with-fireabase/node_modules/@firebase/component/dist/index.esm.js"],"sourcesContent":["import { __values, __read, __awaiter, __generator, __spreadArray } from 'tslib';\nimport { Deferred } from '@firebase/util';\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nvar Component = /** @class */ (function () {\r\n    /**\r\n     *\r\n     * @param name The public service name, e.g. app, auth, firestore, database\r\n     * @param instanceFactory Service factory responsible for creating the public interface\r\n     * @param type whether the service provided by the component is public or private\r\n     */\r\n    function Component(name, instanceFactory, type) {\r\n        this.name = name;\r\n        this.instanceFactory = instanceFactory;\r\n        this.type = type;\r\n        this.multipleInstances = false;\r\n        /**\r\n         * Properties to be added to the service namespace\r\n         */\r\n        this.serviceProps = {};\r\n        this.instantiationMode = \"LAZY\" /* LAZY */;\r\n        this.onInstanceCreated = null;\r\n    }\r\n    Component.prototype.setInstantiationMode = function (mode) {\r\n        this.instantiationMode = mode;\r\n        return this;\r\n    };\r\n    Component.prototype.setMultipleInstances = function (multipleInstances) {\r\n        this.multipleInstances = multipleInstances;\r\n        return this;\r\n    };\r\n    Component.prototype.setServiceProps = function (props) {\r\n        this.serviceProps = props;\r\n        return this;\r\n    };\r\n    Component.prototype.setInstanceCreatedCallback = function (callback) {\r\n        this.onInstanceCreated = callback;\r\n        return this;\r\n    };\r\n    return Component;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\r\nvar Provider = /** @class */ (function () {\r\n    function Provider(name, container) {\r\n        this.name = name;\r\n        this.container = container;\r\n        this.component = null;\r\n        this.instances = new Map();\r\n        this.instancesDeferred = new Map();\r\n        this.instancesOptions = new Map();\r\n        this.onInitCallbacks = new Map();\r\n    }\r\n    /**\r\n     * @param identifier A provider can provide mulitple instances of a service\r\n     * if this.component.multipleInstances is true.\r\n     */\r\n    Provider.prototype.get = function (identifier) {\r\n        // if multipleInstances is not supported, use the default name\r\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\r\n            var deferred = new Deferred();\r\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\r\n            if (this.isInitialized(normalizedIdentifier) ||\r\n                this.shouldAutoInitialize()) {\r\n                // initialize the service if it can be auto-initialized\r\n                try {\r\n                    var instance = this.getOrInitializeService({\r\n                        instanceIdentifier: normalizedIdentifier\r\n                    });\r\n                    if (instance) {\r\n                        deferred.resolve(instance);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // when the instance factory throws an exception during get(), it should not cause\r\n                    // a fatal error. We just return the unresolved promise in this case.\r\n                }\r\n            }\r\n        }\r\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\r\n    };\r\n    Provider.prototype.getImmediate = function (options) {\r\n        var _a;\r\n        // if multipleInstances is not supported, use the default name\r\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\r\n        var optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\r\n        if (this.isInitialized(normalizedIdentifier) ||\r\n            this.shouldAutoInitialize()) {\r\n            try {\r\n                return this.getOrInitializeService({\r\n                    instanceIdentifier: normalizedIdentifier\r\n                });\r\n            }\r\n            catch (e) {\r\n                if (optional) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\r\n            if (optional) {\r\n                return null;\r\n            }\r\n            else {\r\n                throw Error(\"Service \" + this.name + \" is not available\");\r\n            }\r\n        }\r\n    };\r\n    Provider.prototype.getComponent = function () {\r\n        return this.component;\r\n    };\r\n    Provider.prototype.setComponent = function (component) {\r\n        var e_1, _a;\r\n        if (component.name !== this.name) {\r\n            throw Error(\"Mismatching Component \" + component.name + \" for Provider \" + this.name + \".\");\r\n        }\r\n        if (this.component) {\r\n            throw Error(\"Component for \" + this.name + \" has already been provided\");\r\n        }\r\n        this.component = component;\r\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\r\n        if (!this.shouldAutoInitialize()) {\r\n            return;\r\n        }\r\n        // if the service is eager, initialize the default instance\r\n        if (isComponentEager(component)) {\r\n            try {\r\n                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\r\n            }\r\n            catch (e) {\r\n                // when the instance factory for an eager Component throws an exception during the eager\r\n                // initialization, it should not cause a fatal error.\r\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\r\n                // a fatal error in this case?\r\n            }\r\n        }\r\n        try {\r\n            // Create service instances for the pending promises and resolve them\r\n            // NOTE: if this.multipleInstances is false, only the default instance will be created\r\n            // and all promises with resolve with it regardless of the identifier.\r\n            for (var _b = __values(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var _d = __read(_c.value, 2), instanceIdentifier = _d[0], instanceDeferred = _d[1];\r\n                var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n                try {\r\n                    // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\r\n                    var instance = this.getOrInitializeService({\r\n                        instanceIdentifier: normalizedIdentifier\r\n                    });\r\n                    instanceDeferred.resolve(instance);\r\n                }\r\n                catch (e) {\r\n                    // when the instance factory throws an exception, it should not cause\r\n                    // a fatal error. We just leave the promise unresolved.\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    };\r\n    Provider.prototype.clearInstance = function (identifier) {\r\n        if (identifier === void 0) { identifier = DEFAULT_ENTRY_NAME; }\r\n        this.instancesDeferred.delete(identifier);\r\n        this.instancesOptions.delete(identifier);\r\n        this.instances.delete(identifier);\r\n    };\r\n    // app.delete() will call this method on every provider to delete the services\r\n    // TODO: should we mark the provider as deleted?\r\n    Provider.prototype.delete = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var services;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        services = Array.from(this.instances.values());\r\n                        return [4 /*yield*/, Promise.all(__spreadArray(__spreadArray([], __read(services\r\n                                .filter(function (service) { return 'INTERNAL' in service; }) // legacy services\r\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                                .map(function (service) { return service.INTERNAL.delete(); }))), __read(services\r\n                                .filter(function (service) { return '_delete' in service; }) // modularized services\r\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                                .map(function (service) { return service._delete(); }))))];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Provider.prototype.isComponentSet = function () {\r\n        return this.component != null;\r\n    };\r\n    Provider.prototype.isInitialized = function (identifier) {\r\n        if (identifier === void 0) { identifier = DEFAULT_ENTRY_NAME; }\r\n        return this.instances.has(identifier);\r\n    };\r\n    Provider.prototype.getOptions = function (identifier) {\r\n        if (identifier === void 0) { identifier = DEFAULT_ENTRY_NAME; }\r\n        return this.instancesOptions.get(identifier) || {};\r\n    };\r\n    Provider.prototype.initialize = function (opts) {\r\n        var e_2, _a;\r\n        if (opts === void 0) { opts = {}; }\r\n        var _b = opts.options, options = _b === void 0 ? {} : _b;\r\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\r\n        if (this.isInitialized(normalizedIdentifier)) {\r\n            throw Error(this.name + \"(\" + normalizedIdentifier + \") has already been initialized\");\r\n        }\r\n        if (!this.isComponentSet()) {\r\n            throw Error(\"Component \" + this.name + \" has not been registered yet\");\r\n        }\r\n        var instance = this.getOrInitializeService({\r\n            instanceIdentifier: normalizedIdentifier,\r\n            options: options\r\n        });\r\n        try {\r\n            // resolve any pending promise waiting for the service instance\r\n            for (var _c = __values(this.instancesDeferred.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                var _e = __read(_d.value, 2), instanceIdentifier = _e[0], instanceDeferred = _e[1];\r\n                var normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n                if (normalizedIdentifier === normalizedDeferredIdentifier) {\r\n                    instanceDeferred.resolve(instance);\r\n                }\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        return instance;\r\n    };\r\n    /**\r\n     *\r\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n     *\r\n     * @param identifier An optional instance identifier\r\n     * @returns a function to unregister the callback\r\n     */\r\n    Provider.prototype.onInit = function (callback, identifier) {\r\n        var _a;\r\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        var existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\r\n        existingCallbacks.add(callback);\r\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\r\n        var existingInstance = this.instances.get(normalizedIdentifier);\r\n        if (existingInstance) {\r\n            callback(existingInstance, normalizedIdentifier);\r\n        }\r\n        return function () {\r\n            existingCallbacks.delete(callback);\r\n        };\r\n    };\r\n    /**\r\n     * Invoke onInit callbacks synchronously\r\n     * @param instance the service instance`\r\n     */\r\n    Provider.prototype.invokeOnInitCallbacks = function (instance, identifier) {\r\n        var e_3, _a;\r\n        var callbacks = this.onInitCallbacks.get(identifier);\r\n        if (!callbacks) {\r\n            return;\r\n        }\r\n        try {\r\n            for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {\r\n                var callback = callbacks_1_1.value;\r\n                try {\r\n                    callback(instance, identifier);\r\n                }\r\n                catch (_b) {\r\n                    // ignore errors in the onInit callback\r\n                }\r\n            }\r\n        }\r\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n        finally {\r\n            try {\r\n                if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);\r\n            }\r\n            finally { if (e_3) throw e_3.error; }\r\n        }\r\n    };\r\n    Provider.prototype.getOrInitializeService = function (_a) {\r\n        var instanceIdentifier = _a.instanceIdentifier, _b = _a.options, options = _b === void 0 ? {} : _b;\r\n        var instance = this.instances.get(instanceIdentifier);\r\n        if (!instance && this.component) {\r\n            instance = this.component.instanceFactory(this.container, {\r\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\r\n                options: options\r\n            });\r\n            this.instances.set(instanceIdentifier, instance);\r\n            this.instancesOptions.set(instanceIdentifier, options);\r\n            /**\r\n             * Invoke onInit listeners.\r\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n             * while onInit listeners are registered by consumers of the provider.\r\n             */\r\n            this.invokeOnInitCallbacks(instance, instanceIdentifier);\r\n            /**\r\n             * Order is important\r\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n             * makes `isInitialized()` return true.\r\n             */\r\n            if (this.component.onInstanceCreated) {\r\n                try {\r\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\r\n                }\r\n                catch (_c) {\r\n                    // ignore errors in the onInstanceCreatedCallback\r\n                }\r\n            }\r\n        }\r\n        return instance || null;\r\n    };\r\n    Provider.prototype.normalizeInstanceIdentifier = function (identifier) {\r\n        if (identifier === void 0) { identifier = DEFAULT_ENTRY_NAME; }\r\n        if (this.component) {\r\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\r\n        }\r\n        else {\r\n            return identifier; // assume multiple instances are supported before the component is provided.\r\n        }\r\n    };\r\n    Provider.prototype.shouldAutoInitialize = function () {\r\n        return (!!this.component &&\r\n            this.component.instantiationMode !== \"EXPLICIT\" /* EXPLICIT */);\r\n    };\r\n    return Provider;\r\n}());\r\n// undefined should be passed to the service factory for the default instance\r\nfunction normalizeIdentifierForFactory(identifier) {\r\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\r\n}\r\nfunction isComponentEager(component) {\r\n    return component.instantiationMode === \"EAGER\" /* EAGER */;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nvar ComponentContainer = /** @class */ (function () {\r\n    function ComponentContainer(name) {\r\n        this.name = name;\r\n        this.providers = new Map();\r\n    }\r\n    /**\r\n     *\r\n     * @param component Component being added\r\n     * @param overwrite When a component with the same name has already been registered,\r\n     * if overwrite is true: overwrite the existing component with the new component and create a new\r\n     * provider with the new component. It can be useful in tests where you want to use different mocks\r\n     * for different tests.\r\n     * if overwrite is false: throw an exception\r\n     */\r\n    ComponentContainer.prototype.addComponent = function (component) {\r\n        var provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            throw new Error(\"Component \" + component.name + \" has already been registered with \" + this.name);\r\n        }\r\n        provider.setComponent(component);\r\n    };\r\n    ComponentContainer.prototype.addOrOverwriteComponent = function (component) {\r\n        var provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            // delete the existing provider from the container, so we can register the new component\r\n            this.providers.delete(component.name);\r\n        }\r\n        this.addComponent(component);\r\n    };\r\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */\r\n    ComponentContainer.prototype.getProvider = function (name) {\r\n        if (this.providers.has(name)) {\r\n            return this.providers.get(name);\r\n        }\r\n        // create a Provider for a service that hasn't registered with Firebase\r\n        var provider = new Provider(name, this);\r\n        this.providers.set(name, provider);\r\n        return provider;\r\n    };\r\n    ComponentContainer.prototype.getProviders = function () {\r\n        return Array.from(this.providers.values());\r\n    };\r\n    return ComponentContainer;\r\n}());\n\nexport { Component, ComponentContainer, Provider };\n//# sourceMappingURL=index.esm.js.map\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}